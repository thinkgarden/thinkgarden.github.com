---
layout: post
title: js基础知识汇集
description: "由浅入深学习js"
category: js
tags: [学习笔记]
---

###字符串相关
####常用函数
-字符串截取，从第八个字符开始一直到倒数第一个字符
	string.spice(8,-1)

###DOM操作
####元素选择
-querySelectAll
-nextElementSibling

-addClass
-removeClass
-hasClass

####事件相关
-addEvent
-removeEvent
-delegateEvent

###事件相关
- 标准事件对象
	type、target、stopPropagation()、 preventDefault()
-ie事件对象
	type、srcElement、cancelbabble、 returnValue


-获取element相对于浏览器窗口的位置

###对象相关

-作用域
作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和函数作用域两种，js中没有块级作用域。
<br>
JS权威指南中有一句很精辟的描述:　”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”　
```javascript

    function factory() {
         var name = 'laruence';
         var intro = function(){
              alert('I am ' + name);
         }
         return intro;
    }
     
    function app(para){
         var name = para;
         var func = factory();
         func();
    }
     
    app('eve'); //I am laruence

```

-函数的声明周期
函数的生命周期分为两个阶段：声明阶段和执行阶段。赋值操作是在执行阶段完成。

-执行上下文
每次函数调用是都会有一个执行上下文，默认有一个全局上下文。

-JS解释器如何找到我们定义的函数和变量？
变量对象（VO）:储存执行上下文中定义的变量、函数声明、函数参数。js函数中定义的变量和声明的函数都是从变量对象中去查找的。


-变量初始化阶段
VO按照如下顺序填充:
-函数参数 (若未传入，初始化该参数值为undefined)
-函数声明 (若发生命名冲突，会覆盖)
-变量声明 (初始化变量值为 undefined，若发生命名冲突，会忽略。)
```javascript
 function foo(x, y, z) {
     function x() {};
     console.log(x);
 }
 foo(100); // funtion x()

 function foo2(x, y, z) {
     var x = 50;
     console.log(x);
 }
 foo2(110); // 50

 function foo3() {
     function x() {};
     var x = 100;
     console.log(x);
 }
 foo3(); // 100

 function foo4() {
     function x() {};
     var x;
     console.log(x);
 }
 foo4(); // funtion x()

```

-代码执行阶段
给 VO 对象内的变量赋值。 VO 变为 AO （活动对象 activation object）。

```javascript
alert(x); // function

var x = 10;
alert(x); // 10
x = 20;

function x() {}
alert(x); // 20

if (true) {
    var a = 1;
} else {
    var b = true;
}

alert(a); // 1
alert(b); // undefined
```
****执行分析
-声明阶段
vo对象是一个全局作用域。根据vo的执行顺序，它会先去查找函数声明，则会在vo对象中
vo={
	x：function
}
接下来会去查找变量声明，因为变量对象中已经保存了x，所以变量x的声明会被忽略,js中没有块级作用域所以
变量a、bd都属于全局作用域，也会被保存在vo对象中。<br>
vo={
	x：function，
	a:undefined,
	b:undefined

}
-执行阶段
alert(x) //funtion
执行赋值操作var x=10
vo={
	x:10,
	a:undefined,
	b:undefined

}
执行赋值操作var x=20
vo={
	x:20,
	a:undefined,
	b:undefined
}
由于函数声明是被前置的所以function x() {}会被忽略，所以
vo={
	x:20,
	a:undefined,
	b:undefined
}
执行if判断后
vo={
	x:20,
	a:1,
	b:undefined
}

-原型模式：我们创建的每个函数都会有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

-理解原型对象：在默认情况下所有原型对象都会获得一个constructor属性

-构造函数、原型和实例的关系
每个构造函数都包含一个原型对象，原型对象包含一个指向构造函数的指针，而实例包含一个指向原型对象的内部指针。

-原型链
如果让原型对象等于另一个类型的实例的话，（由于每个实例都包含一个指向原型对象的指针）则原型对象中就会包含一个指向另一个原型对象的指针。响应地，另一个原型中也包含着指向另一个构造函数的指针。假设另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。

-判断对象类型
Object.prototype.toString.call(fn) === '[object Function]';
-对象clone
-扩展对象
对象迭代时需要判断该属性是否属于自身 obj.hasOwnProperty(key)

    
###数组相关
-检测数组isArray
-数组迭代
-删除数组中的第i个元素
array.splice(i,1);
array.join()

###继承相关

####Date相关
- 创建一个日期
- 获得年份、月份、天数、星期



