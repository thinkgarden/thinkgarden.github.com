---
layout: post
title: js基础知识汇集
description: "由浅入深学习js"
category: js
tags: [学习笔记]
---

###字符串相关
####常用函数
-字符串截取，从第八个字符开始一直到倒数第一个字符
	string.spice(8,-1)

###DOM操作
####元素选择
-querySelectAll
-nextElementSibling

-addClass
-removeClass
-hasClass

####事件相关
-addEvent
-removeEvent
-delegateEvent

###事件相关
- 标准事件对象
	type、target、stopPropagation()、 preventDefault()
-ie事件对象
	type、srcElement、cancelbabble、 returnValue


-获取element相对于浏览器窗口的位置

###作用域和作用域链
####核心：搞清楚当前的执行上下文。
执行上下文是一个堆栈结构，默认最外层是全局上下文，里面保存了全局作用域中定义的函数、变量。执行上下文中定义或声明的函数、变量都保存在变量对象中。js解释器就是从变量对象中去寻找我们定义的变量和函数。
-作用域
作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和函数作用域两种，js中没有块级作用域。<br>
<br>
JS权威指南中有一句很精辟的描述:　”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”<br>

    function factory() {
         var name = 'laruence';
         var intro = function(){
              alert('I am ' + name);
         }
         return intro;
    }
     
    function app(para){
         var name = para;
         var func = factory();
         func();
    }
     
    app('eve'); //I am laruence

-作用域链（执行上下文）堆栈结构

    var name = 'laruence';
         function echo() {
              alert(name);
         }
 
    function env() {
          var name = 'eve';
          echo();
    }
 
    env(); //laruence

#### 参考文档
* [鸟哥：Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)

-函数的生命周期
函数的生命周期分为两个阶段：声明阶段和执行阶段。赋值操作是在执行阶段完成。

-执行上下文
每次函数调用是都会有一个执行上下文，默认有一个全局上下文。

-JS解释器如何找到我们定义的函数和变量？
变量对象（VO）:储存执行上下文中定义的变量、函数声明、函数参数。js函数中定义的变量和声明的函数都是从变量对象中去查找的。

-变量初始化阶段
VO按照如下顺序填充:
-函数参数 (若未传入，初始化该参数值为undefined)
-函数声明 (若发生命名冲突，会覆盖)
-变量声明 (初始化变量值为 undefined，若发生命名冲突，会忽略。)

```
 function foo(x, y, z) {
     function x() {};
     console.log(x);
 }
 foo(100); // funtion x()

 function foo2(x, y, z) {
     var x = 50;
     console.log(x);
 }
 foo2(110); // 50

 function foo3() {
     function x() {};
     var x = 100;
     console.log(x);
 }
 foo3(); // 100

 function foo4() {
     function x() {};
     var x;
     console.log(x);
 }
 foo4(); // funtion x()

```

-代码执行阶段
给 VO 对象内的变量赋值。 VO 变为 AO （活动对象 activation object）。

```
alert(x); // function

var x = 10;
alert(x); // 10
x = 20;

function x() {}
alert(x); // 20

if (true) {
    var a = 1;
} else {
    var b = true;
}

alert(a); // 1
alert(b); // undefined
```
****执行分析
-声明阶段
vo对象是一个全局作用域。根据vo的执行顺序，它会先去查找函数声明，则会在vo对象中
vo={
	x：function
}
接下来会去查找变量声明，因为变量对象中已经保存了x，所以变量x的声明会被忽略,js中没有块级作用域所以
变量a、b都属于全局作用域，也会被保存在vo对象中。<br>
vo={
	x：function，
	a:undefined,
	b:undefined

}
-执行阶段
alert(x) //funtion
执行赋值操作var x=10
vo={
	x:10,
	a:undefined,
	b:undefined

}
执行赋值操作var x=20
vo={
	x:20,
	a:undefined,
	b:undefined
}
由于函数声明是被前置的所以function x() {}会被忽略，所以
vo={
	x:20,
	a:undefined,
	b:undefined
}
执行if判断后
vo={
	x:20,
	a:1,
	b:undefined
}

-闭包
闭包首先是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。
闭包的作用归结起来就是：为了在函数外部读取到函数内部定义的变量具体的作用可以细化，如，模仿私有属性；缓存变量的值，及让变量的值一直保存在内存中等。

###对象




###继承

####什么是原型？
原型是一个对象，每个对象都有一个原型，对象的原型通常都是构造器的prototype指向的对象。其他对象可以通过它实现属性继承。

####哪些对象有原型
所有的对象在默认的情况下都有一个原型，因为原型本身也是对象，所以每个原型自身又有一个原型(只有一种例外，默认的对象原型在原型链的顶端。更多关于原型链的将在后面介绍)

####prototype属性与原型
原型与prototype不一样。每个对象默认都有一个原型，chrome中通过_proto_取得，es5中通过Object.getPrototypeOf(object)取得。每个函数默认都有一个prototype属性，它指向一个对象，我们通常将它成为原型对象。


-原型模式：我们创建的每个函数都会有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。


-构造函数、原型和实例的关系
每个构造函数都包含一个原型对象，原型对象包含一个指向构造函数的指针，而实例包含一个指向原型对象的内部指针。

-原型链
如果让原型对象等于另一个类型的实例的话，（由于每个实例都包含一个指向原型对象的指针）则原型对象中就会包含一个指向另一个原型对象的指针。响应地，另一个原型中也包含着指向另一个构造函数的指针。假设另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。

![原型链](http://7xnaen.com1.z0.glb.clouddn.com/blog-原型链.png)

####instanceof
    console.log([1, 2] instanceof Array); //true
    console.log([1, 2] instanceof Object); //true
    console.log(new Object() instanceof Array); //false

左边要求是对象，右边要求是构造器或函数。它会判断：右边的构造器中的prototype 属性是否出现在左边的对象的原型链上。


-判断对象类型
Object.prototype.toString.call(fn) === '[object Function]';
-对象clone
-扩展对象
对象迭代时需要判断该属性是否属于自身 obj.hasOwnProperty(key)

    
###数组相关
-检测数组isArray
-数组迭代
-删除数组中的第i个元素
array.splice(i,1);
array.join()

###继承相关

####Date相关
- 创建一个日期
- 获得年份、月份、天数、星期



