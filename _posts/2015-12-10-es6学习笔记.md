---
layout: post
title: es6学习笔记
category: web前端
tags: [web前端]
---

## 新特性

### 箭头（Arrow）
 ````=> ````是function的简写形式，支持````expression```` 和 ````statement```` 两种形式。同时一点很重要的是它拥有词法作用域的this值，帮你很好的解决this的指向问题，这是一个很酷的方式，可以帮你减少一些代码的编写，先来看看它的语法。

    ([param] [, param]) => {
       statements
    }
    param => expression

来看个具体的例子：

    const arr = [1,2,3];
    var temp = [];
    // Expression bodies
    // param => expression
    arr.map(item => item+1);
    arr.map((item,index) => item+1);

    // Statement bodies
    // ([param][,param])=>{statements}
    arr.forEach(item=>{
      if (item==1) {
        temp.push(item);
      };
    })

### 类（class）
ES6 引入了class（类），让javascript的面向对象编程变得更加容易清晰和容易理解。类只是基于原型的面向对象模式的语法糖。

    class Animal {
      // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.
      constructor(name,color) {
        this.name = name;
        this.color = color;
      }
      // toString 是原型对象上的属性
      toString() {
        console.log('name:' + this.name + ',color:' + this.color);

      }
    }

   var animal = new Animal('dog','white');
   animal.toString();

   console.log(animal.hasOwnProperty('name')); //true
   console.log(animal.hasOwnProperty('toString')); // false
   console.log(animal.__proto__.hasOwnProperty('toString')); // true

   class Cat extends Animal {
    constructor(action) {
      // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错.
      // 如果没有置顶consructor,默认带super方法的constructor将会被添加、
      super('cat','white');
      this.action = action;
    }
    toString() {
      console.log(super.toString());
    }
   }

   var cat = new Cat('catch')
   cat.toString();

   // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。
   console.log(cat instanceof Cat); // true
   console.log(cat instanceof Animal); // true

#### 类的 ````prototype```` 属性和 ````__proto__ ````属性

一个实例化对象会有一个 ````__proto__```` 指向构造函数的 `````prototype```` 属性。在 class 中。同时具有 ````__proto__```` 和 ````prototype```` 两个属性，存在两条继承链。

* 子类的 ````__proto__```` 属性，表示构造函数的继承，总是指向父类。
* 子类的 ````prototype```` 的 ````__proto__```` 属性表示方法的继承，总是指向父类的 ````prototype```` 属性。

    class Cat extends Animal {}
    console.log(Cat.__proto__ === Animal); // true
    console.log(Cat.prototype.__proto__ === Animal.prototype); // true

### Module
到目前为止,javascript (ES5及以前) 还不能支持原生的模块化，大多数的解决方案都是通过引用外部的库来实现模块化。比如 遵循CMD规范的 Seajs 和AMD的 RequireJS 。在ES6中，模块将作为重要的组成部分被添加进来。模块的功能主要由 ````export```` 和 ````import```` 组成.每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 ````export ````来规定模块对外暴露的接口，通过````import````来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。

#### export,import 命令

    //test.js
    export var name = 'Rainbow'

ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。

    //test.js
    var name = 'Rainbow';
    var age = '24';
    export {name, age};

定义好模块的输出以后就可以在另外一个模块通过import引用。

    //index.js
    import {name, age} from './test.js'


1、新增块级作用域，用关键字let、const表示；


